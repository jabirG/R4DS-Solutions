{
  "hash": "69b793e693b0c751ab62890e34a62502",
  "result": {
    "markdown": "---\ntitle: \"Exploratory data analysis\"\n---\n\n\n## Notes\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.0     ✔ purrr   1.0.1\n✔ tibble  3.1.8     ✔ dplyr   1.1.0\n✔ tidyr   1.3.0     ✔ stringr 1.5.0\n✔ readr   2.1.3     ✔ forcats 1.0.0\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n```\n:::\n\n```{.r .cell-code}\nlibrary(ggbeeswarm)\n```\n:::\n\n\nScatterplots become less useful as the size of your dataset grows, because points begin to overplot, and pile up into areas of uniform black (as above). You've already seen one way to fix the problem: using the `alpha` aesthetic to add transparency\n\nBut using transparency can be challenging for very large datasets. Another solution is to use bin. Previously you used [`geom_histogram()`](https://ggplot2.tidyverse.org/reference/geom_histogram.html) and [`geom_freqpoly()`](https://ggplot2.tidyverse.org/reference/geom_histogram.html) to bin in one dimension. Now you'll learn how to use [`geom_bin2d()`](https://ggplot2.tidyverse.org/reference/geom_bin_2d.html) and [`geom_hex()`](https://ggplot2.tidyverse.org/reference/geom_hex.html) to bin in two dimensions.\n\ngeom_bin2d() and [`geom_hex()`](https://ggplot2.tidyverse.org/reference/geom_hex.html) divide the coordinate plane into 2d bins and then use a fill color to display how many points fall into each bin. [`geom_bin2d()`](https://ggplot2.tidyverse.org/reference/geom_bin_2d.html) creates rectangular bins. [`geom_hex()`](https://ggplot2.tidyverse.org/reference/geom_hex.html) creates hexagonal bins. You will need to install the hexbin package to use [`geom_hex()`](https://ggplot2.tidyverse.org/reference/geom_hex.html).\n\nHeatmaply package and seriation package:\n\nIf the categorical variables are unordered, you might want to use the seriation package to simultaneously reorder the rows and columns in order to more clearly reveal interesting patterns. For larger plots, you might want to try the heatmaply package, which creates interactive plots.\n\nAnother approach for exploring the relationship between these variables is computing the counts with dplyr:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |> \n  count(color, cut)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 35 × 3\n   color cut           n\n   <ord> <ord>     <int>\n 1 D     Fair        163\n 2 D     Good        662\n 3 D     Very Good  1513\n 4 D     Premium    1603\n 5 D     Ideal      2834\n 6 E     Fair        224\n 7 E     Good        933\n 8 E     Very Good  2400\n 9 E     Premium    2337\n10 E     Ideal      3903\n# … with 25 more rows\n```\n:::\n\n```{.r .cell-code}\n#> # A tibble: 35 × 3\n#>   color cut           n\n#>   <ord> <ord>     <int>\n#> 1 D     Fair        163\n#> 2 D     Good        662\n#> 3 D     Very Good  1513\n#> 4 D     Premium    1603\n#> 5 D     Ideal      2834\n#> 6 E     Fair        224\n#> # … with 29 more rows\n```\n:::\n\n\nThen visualize with [`geom_tile()`](https://ggplot2.tidyverse.org/reference/geom_tile.html) and the fill aesthetic:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |> \n  count(color, cut) |>  \n  ggplot(aes(x = color, y = cut)) +\n  geom_tile(aes(fill = n))\n```\n\n::: {.cell-output-display}\n![](chapter-12_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nTo visualize the covariation between categorical variables, you'll need to count the number of observations for each combination of levels of these categorical variables. One way to do that is to rely on the built-in `geom_count()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(diamonds, aes(x = cut, y = color)) +\n  geom_count()\n```\n\n::: {.cell-output-display}\n![](chapter-12_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nInstead, we recommend replacing the unusual values with missing values. The easiest way to do this is to use [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.html) to replace the variable with a modified copy. You can use the [`if_else()`](https://dplyr.tidyverse.org/reference/if_else.html) function to replace unusual values with `NA`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |> \n  mutate(y = if_else(y < 3 | y > 20, NA, y))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 53,940 × 10\n   carat cut       color clarity depth table price     x     y     z\n   <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n 4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n 5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n 6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n 7  0.24 Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47\n 8  0.26 Very Good H     SI1      61.9    55   337  4.07  4.11  2.53\n 9  0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49\n10  0.23 Very Good H     VS1      59.4    61   338  4     4.05  2.39\n# … with 53,930 more rows\n```\n:::\n:::\n\n\ncoord_cartesian() zoom into y\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(diamonds, aes(x = y)) + \n  geom_histogram(binwidth = 0.5) +\n  coord_cartesian(ylim = c(0, 50))\n```\n\n::: {.cell-output-display}\n![](chapter-12_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n## Questions\n\n## Exercise 12.3.3\n\n1.Explore the distribution of each of the `x`, `y`, and `z` variables in `diamonds`. What do you learn? Think about a diamond and how you might decide which dimension is the length, width, and depth.\n\nlook up help ?diamonds\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\n\nggplot(diamonds, aes(x = x , y = y)) + geom_point()\n```\n\n::: {.cell-output-display}\n![](chapter-12_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nx is the length, y is the width, z is the depth\n\n2.Explore the distribution of `price`. Do you discover anything unusual or surprising? (Hint: Carefully think about the `binwidth` and make sure you try a wide range of values.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(diamonds, aes(x = price)) + geom_histogram(binwidth = 2000)\n```\n\n::: {.cell-output-display}\n![](chapter-12_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n3.How many diamonds are 0.99 carat? How many are 1 carat? What do you think is the cause of the difference?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(diamonds, aes(x = carat)) + geom_histogram(binwidth = .1)\n```\n\n::: {.cell-output-display}\n![](chapter-12_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n4.Compare and contrast [`coord_cartesian()`](https://ggplot2.tidyverse.org/reference/coord_cartesian.html) vs. [`xlim()`](https://ggplot2.tidyverse.org/reference/lims.html) or [`ylim()`](https://ggplot2.tidyverse.org/reference/lims.html) when zooming in on a histogram. What happens if you leave `binwidth` unset? What happens if you try and zoom so only half a bar shows?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(diamonds, aes(x = carat)) + geom_histogram(binwidth = .1) +\n  coord_cartesian(xlim = c(0,50))\n```\n\n::: {.cell-output-display}\n![](chapter-12_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n\n```{.r .cell-code}\nggplot(diamonds, aes(x = carat)) + geom_histogram(binwidth = .1) + \n  coord_cartesian(ylim = c(0,50))\n```\n\n::: {.cell-output-display}\n![](chapter-12_files/figure-html/unnamed-chunk-10-2.png){width=672}\n:::\n:::\n\n\nso it looks like when you use the xlim it zooms out but when you use the ylim it zooms in\n\n## Exercise 12.4.1\n\n1.What happens to missing values in a histogram? What happens to missing values in a bar chart? Why is there a difference in how missing values are handled in histograms and bar charts?\n\nthe missing values are removed with a warning\n\n2.What does `na.rm = TRUE` do in [`mean()`](https://rdrr.io/r/base/mean.html) and [`sum()`](https://rdrr.io/r/base/sum.html)?\n\nfor mean it determines whether na's should be removed or not and for sum should na values be removed and certain other values\n\n## Exercise 12.5.1.1\n\n1.Use what you've learned to improve the visualization of the departure times of cancelled vs. non-cancelled flights.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncanceled_flights <- nycflights13::flights |> \n  mutate(\n    cancelled = is.na(dep_time),\n    sched_hour = sched_dep_time %/% 100,\n    sched_min = sched_dep_time %% 100,\n    sched_dep_time = sched_hour + (sched_min / 60)\n  ) \n\nggplot(canceled_flights,aes(x = cancelled)) +\n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](chapter-12_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n2.What variable in the diamonds dataset is most important for predicting the price of a diamond? How is that variable correlated with cut? Why does the combination of those two relationships lead to lower quality diamonds being more expensive?\n\ni would say maybe clarity or just straight up price, i think because the lower quality diamonds correspond to people buying them who don't really know about diamonds or don't care about the quality,theres alot more lower quality diamonds than higher quality\n\n?diamonds\n\n3.Instead of exchanging the x and y variables, add [`coord_flip()`](https://ggplot2.tidyverse.org/reference/coord_flip.html) as a new layer to the vertical boxplot to create a horizontal one. How does this compare to using exchanging the variables?\n\nit switching the x and y its alot faster\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(mpg, aes(x = hwy, y = fct_reorder(class, hwy, median))) +\n  geom_boxplot() + coord_flip()\n```\n\n::: {.cell-output-display}\n![](chapter-12_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n4.One problem with boxplots is that they were developed in an era of much smaller datasets and tend to display a prohibitively large number of \"outlying values\". One approach to remedy this problem is the letter value plot. Install the lvplot package, and try using `geom_lv()` to display the distribution of price vs. cut. What do you learn? How do you interpret the plots?\n\nmy version of r can't get this\n\n5.Compare and contrast [`geom_violin()`](https://ggplot2.tidyverse.org/reference/geom_violin.html) with a faceted [`geom_histogram()`](https://ggplot2.tidyverse.org/reference/geom_histogram.html), or a colored [`geom_freqpoly()`](https://ggplot2.tidyverse.org/reference/geom_histogram.html). What are the pros and cons of each method?\n\ngeom_violin shows a basic understanding of the amount of diamonds while geom_histogram shows the further outliers better and where they are and geom_freqpoly shows the count better\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(diamonds,aes(x = price, y = clarity)) +\n  geom_violin()\n```\n\n::: {.cell-output-display}\n![](chapter-12_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(diamonds,aes(x = price)) +\n  geom_histogram() +\n  facet_wrap(~clarity, ncol = 1, scales = \"free_y\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n:::\n\n::: {.cell-output-display}\n![](chapter-12_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n\n```{.r .cell-code}\n#> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(diamonds,aes(x = price, color = clarity)) +\n  geom_freqpoly()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n:::\n\n::: {.cell-output-display}\n![](chapter-12_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n\n```{.r .cell-code}\n#> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n:::\n\n\n6.If you have a small dataset, it's sometimes useful to use [`geom_jitter()`](https://ggplot2.tidyverse.org/reference/geom_jitter.html) to see the relationship between a continuous and categorical variable. The ggbeeswarm package provides a number of methods similar to [`geom_jitter()`](https://ggplot2.tidyverse.org/reference/geom_jitter.html). List them and briefly describe what each one does\n\nso geom_beeswarm makes it so you have more control over overplotting datasets, while geom_jitter to me seems like just a default that you can use on the go but if you do want more customization ggbeeswarm is better for handling overplotting\n\n## Exercise 12.5.2.1\n\n1.How could you rescale the count dataset above to more clearly show the distribution of cut within color, or color within cut?\n\ni can use this code from earlier that shows exactly that\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(diamonds, aes(x = cut, y = color)) +\n  geom_count()\n```\n\n::: {.cell-output-display}\n![](chapter-12_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n2.How does the segmented bar chart change if color is mapped to the `x` aesthetic and `cut` is mapped to the `fill` aesthetic? Calculate the counts that fall into each of the segments.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount(diamonds,color,cut)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 35 × 3\n   color cut           n\n   <ord> <ord>     <int>\n 1 D     Fair        163\n 2 D     Good        662\n 3 D     Very Good  1513\n 4 D     Premium    1603\n 5 D     Ideal      2834\n 6 E     Fair        224\n 7 E     Good        933\n 8 E     Very Good  2400\n 9 E     Premium    2337\n10 E     Ideal      3903\n# … with 25 more rows\n```\n:::\n\n```{.r .cell-code}\n ggplot(diamonds,aes( x = color, fill = cut)) +\n  geom_bar(position = \"fill\")\n```\n\n::: {.cell-output-display}\n![](chapter-12_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n3.Use [`geom_tile()`](https://ggplot2.tidyverse.org/reference/geom_tile.html) together with dplyr to explore how average flight delays vary by destination and month of year. What makes the plot difficult to read? How could you improve it?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(nycflights13::flights)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 336,776\nColumns: 19\n$ year           <int> 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2…\n$ month          <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ day            <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ dep_time       <int> 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 558, …\n$ sched_dep_time <int> 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 600, …\n$ dep_delay      <dbl> 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2, -1…\n$ arr_time       <int> 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 849,…\n$ sched_arr_time <int> 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 851,…\n$ arr_delay      <dbl> 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7, -1…\n$ carrier        <chr> \"UA\", \"UA\", \"AA\", \"B6\", \"DL\", \"UA\", \"B6\", \"EV\", \"B6\", \"…\n$ flight         <int> 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301, 4…\n$ tailnum        <chr> \"N14228\", \"N24211\", \"N619AA\", \"N804JB\", \"N668DN\", \"N394…\n$ origin         <chr> \"EWR\", \"LGA\", \"JFK\", \"JFK\", \"LGA\", \"EWR\", \"EWR\", \"LGA\",…\n$ dest           <chr> \"IAH\", \"IAH\", \"MIA\", \"BQN\", \"ATL\", \"ORD\", \"FLL\", \"IAD\",…\n$ air_time       <dbl> 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149, 1…\n$ distance       <dbl> 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 733, …\n$ hour           <dbl> 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6…\n$ minute         <dbl> 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0…\n$ time_hour      <dttm> 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-01 0…\n```\n:::\n\n```{.r .cell-code}\nnycflights13::flights %>% summarise(dest,month,year) %>% \n  group_by(dest,month)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Returning more (or less) than 1 row per `summarise()` group was deprecated in\ndplyr 1.1.0.\nℹ Please use `reframe()` instead.\nℹ When switching from `summarise()` to `reframe()`, remember that `reframe()`\n  always returns an ungrouped data frame and adjust accordingly.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 336,776 × 3\n# Groups:   dest, month [1,113]\n   dest  month  year\n   <chr> <int> <int>\n 1 IAH       1  2013\n 2 IAH       1  2013\n 3 MIA       1  2013\n 4 BQN       1  2013\n 5 ATL       1  2013\n 6 ORD       1  2013\n 7 FLL       1  2013\n 8 IAD       1  2013\n 9 MCO       1  2013\n10 ORD       1  2013\n# … with 336,766 more rows\n```\n:::\n:::\n\n\n## Exercise 12.5.3.1\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsmaller <- diamonds |> \n  filter(carat < 3)\n```\n:::\n\n\n1.Instead of summarizing the conditional distribution with a boxplot, you could use a frequency polygon. What do you need to consider when using [`cut_width()`](https://ggplot2.tidyverse.org/reference/cut_interval.html) vs. [`cut_number()`](https://ggplot2.tidyverse.org/reference/cut_interval.html)? How does that impact a visualization of the 2d distribution of `carat` and `price`?\n\nif you want to use cut_width know you r datas values,if you use cut_number know your sample size\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# visualize price binning by carat, cut_width()\nggplot(smaller, aes(x = price, y = ..density..,)) +\n  geom_freqpoly(aes(color = cut_width(carat, 0.5)))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: The dot-dot notation (`..density..`) was deprecated in ggplot2 3.4.0.\nℹ Please use `after_stat(density)` instead.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n:::\n\n::: {.cell-output-display}\n![](chapter-12_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# visualize price binning by carat, cut_number(), 10 bins\nggplot(smaller, aes(x = price, y = ..density..,)) +\n  geom_freqpoly(aes(color = cut_number(carat, 10)))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n:::\n\n::: {.cell-output-display}\n![](chapter-12_files/figure-html/unnamed-chunk-20-2.png){width=672}\n:::\n:::\n\n\n2.Visualize the distribution of `carat`, partitioned by `price`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(diamonds, aes(x = price, y = carat)) + \n  geom_boxplot()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Continuous x aesthetic\nℹ did you forget `aes(group = ...)`?\n```\n:::\n\n::: {.cell-output-display}\n![](chapter-12_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n3.How does the price distribution of very large diamonds compare to small diamonds? Is it as you expect, or does it surprise you?\n\nits not what i expect even the large diamonds are the same price as smaller diamonds\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(diamonds,aes(x = carat,y = price)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](chapter-12_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n4.Combine two of the techniques you've learned to visualize the combined distribution of cut, carat, and price.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(diamonds,aes(x = price,color = cut,fill = cut)) +\n  geom_freqpoly()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n:::\n\n::: {.cell-output-display}\n![](chapter-12_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(diamonds,aes(x = carat,color = cut,fill = cut)) +\n  geom_freqpoly()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n:::\n\n::: {.cell-output-display}\n![](chapter-12_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n5.Two dimensional plots reveal outliers that are not visible in one dimensional plots. For example, some points in the following plot have an unusual combination of `x` and `y` values, which makes the points outliers even though their `x` and `y` values appear normal when examined separately. Why is a scatterplot a better display than a binned plot for this case?\n\nbecause this scatterplot shows outliers and binned plots don't\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |> \n  filter(x >= 4) |> \n  ggplot(aes(x = x, y = y)) +\n  geom_point() +\n  coord_cartesian(xlim = c(4, 11), ylim = c(4, 11))\n```\n\n::: {.cell-output-display}\n![](chapter-12_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |> \n  filter(x >= 4) |> \nggplot(aes(x = x)) +\n  geom_histogram()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n:::\n\n::: {.cell-output-display}\n![](chapter-12_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\n6.Instead of creating boxes of equal width with [`cut_width()`](https://ggplot2.tidyverse.org/reference/cut_interval.html), we could create boxes that contain roughly equal number of points with [`cut_number()`](https://ggplot2.tidyverse.org/reference/cut_interval.html). What are the advantages and disadvantages of this approach?\n\nif you want to control the width you use cut_width, if you want to choose the number of bins use cut_number\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(smaller, aes(x = carat, y = price)) + \n  geom_boxplot(aes(group = cut_number(carat, 20)))\n```\n\n::: {.cell-output-display}\n![](chapter-12_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n\n```{.r .cell-code}\nsmaller %>% \n  mutate(carat_group = cut_number(carat,20)) %>% \n  count(carat_group)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 20 × 2\n   carat_group     n\n   <fct>       <int>\n 1 [0.2,0.3]    4203\n 2 (0.3,0.31]   2249\n 3 (0.31,0.32]  1840\n 4 (0.32,0.35]  2766\n 5 (0.35,0.4]   3333\n 6 (0.4,0.42]   2088\n 7 (0.42,0.5]   2453\n 8 (0.5,0.53]   2653\n 9 (0.53,0.6]   2863\n10 (0.6,0.7]    2714\n11 (0.7,0.73]   2550\n12 (0.73,0.9]   3890\n13 (0.9,1]      2836\n14 (1,1.01]     2242\n15 (1.01,1.04]  1881\n16 (1.04,1.13]  2692\n17 (1.13,1.23]  2584\n18 (1.23,1.51]  3468\n19 (1.51,1.7]   1950\n20 (1.7,2.8]    2645\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(smaller, aes(x = carat, y = price)) + \n  geom_boxplot(aes(group = cut_width(carat, .1)))\n```\n\n::: {.cell-output-display}\n![](chapter-12_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n\n```{.r .cell-code}\nsmaller %>% \n  mutate(carat_group = cut_width(carat,.1)) %>% \n  count(carat_group)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 27 × 2\n   carat_group     n\n   <fct>       <int>\n 1 [0.15,0.25]   785\n 2 (0.25,0.35] 10273\n 3 (0.35,0.45]  6231\n 4 (0.45,0.55]  5417\n 5 (0.55,0.65]  2328\n 6 (0.65,0.75]  5249\n 7 (0.75,0.85]  1725\n 8 (0.85,0.95]  2656\n 9 (0.95,1.05]  6258\n10 (1.05,1.15]  2687\n# … with 17 more rows\n```\n:::\n:::\n",
    "supporting": [
      "chapter-12_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}